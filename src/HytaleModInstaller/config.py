# src/HytaleModInstaller/config.py
from __future__ import annotations
import argparse
import os
from pathlib import Path
import shutil
import subprocess

from platformdirs import user_config_dir
import tomllib


APP_NAME = "hytalemodinstaller"
SERVICE_NAME = f"{APP_NAME}.service"

DEFAULT_STAGING_DIR = Path.home() / "Downloads" / "HytaleMods"
DEFAULT_MODS_DIR = (
        Path.home()
        / ".var/app/com.hypixel.HytaleLauncher/data/Hytale/UserData/Mods"
)


def systemd_user_unit_path() -> Path:
    return Path.home() / ".config" / "systemd" / "user" / SERVICE_NAME


# noinspection PyDeprecation
def find_executable() -> str:
    exe = shutil.which(APP_NAME)
    if not exe:
        raise SystemExit(f"Could not find '{APP_NAME}' on PATH. Is it installed?")
    return exe


def write_systemd_user_service(*, exec_start: str) -> Path:
    unit_path = systemd_user_unit_path()
    unit_path.parent.mkdir(parents=True, exist_ok=True)

    unit_text = (
        "[Unit]\n"
        f"Description={APP_NAME} watcher\n"
        "\n"
        "[Service]\n"
        "Type=simple\n"
        f"ExecStart={exec_start} run\n"
        "Restart=on-failure\n"
        "RestartSec=2\n"
        "Environment=PYTHONUNBUFFERED=1\n"
        "NoNewPrivileges=true\n"
        "\n"
        "[Install]\n"
        "WantedBy=default.target\n"
    )
    unit_path.write_text(unit_text, encoding="utf-8")
    return unit_path


def _systemctl_user(*args: str) -> None:
    subprocess.run(["systemctl", "--user", *args], check=True)


def _journalctl_user(*args: str) -> None:
    subprocess.run(["journalctl", "--user", *args], check=True)


def install_user_service() -> Path:
    exe = find_executable()
    unit_path = write_systemd_user_service(exec_start=exe)
    _systemctl_user("daemon-reload")
    _systemctl_user("enable", "--now", SERVICE_NAME)
    return unit_path


def uninstall_user_service() -> None:
    _systemctl_user("disable", "--now", SERVICE_NAME)
    unit_path = systemd_user_unit_path()
    if unit_path.exists():
        unit_path.unlink()
    _systemctl_user("daemon-reload")


def follow_user_service_logs() -> None:
    _journalctl_user("-u", SERVICE_NAME, "-f")


def default_config_path() -> Path:
    return Path(user_config_dir(APP_NAME)) / "config.toml"


def load_user_config(config_path: Path) -> dict:
    if not config_path.is_file():
        return {}
    with config_path.open("rb") as f:
        data = tomllib.load(f)
    return data if isinstance(data, dict) else {}


def write_user_config(config_path: Path, *, staging_dir: Path, mods_dir: Path) -> None:
    config_path.parent.mkdir(parents=True, exist_ok=True)
    text = (
        "# Generated by hytalemodinstaller --install\n"
        f'staging_dir = "{staging_dir.as_posix()}"\n'
        f'mods_dir = "{mods_dir.as_posix()}"\n'
    )
    config_path.write_text(text, encoding="utf-8")


def _prompt_path(prompt: str, default: Path) -> Path:
    raw = input(f"{prompt} [{default}]: ").strip()
    chosen = default if raw == "" else Path(raw).expanduser()
    return chosen


def run_install_wizard(config_path: Path) -> None:
    print(f"This will write config to: {config_path}")
    print("Press Enter to accept defaults.\n")

    staging_dir = _prompt_path("Staging directory (watched folder)", DEFAULT_STAGING_DIR)
    mods_dir = _prompt_path("Hytale Mods directory (install target)", DEFAULT_MODS_DIR)

    staging_dir = staging_dir.expanduser()
    mods_dir = mods_dir.expanduser()

    write_user_config(config_path, staging_dir=staging_dir, mods_dir=mods_dir)

    print("\nSaved configuration.")
    print(f"  staging_dir: {staging_dir}")
    print(f"  mods_dir:    {mods_dir}")
    print(f"Config file: {config_path}")

    answer = input("\nInstall and start a systemd *user* service to run at login? [y/N]: ").strip().lower()
    if answer in ("y", "yes"):
        try:
            unit_path = install_user_service()
            print(f"Installed and started: {SERVICE_NAME}")
            print(f"Unit file: {unit_path}")
            print(f"View logs: systemctl --user status {SERVICE_NAME} && journalctl --user -u {SERVICE_NAME} -f")
        except FileNotFoundError:
            print("systemctl/journalctl not found. Skipping service install.")
        except subprocess.CalledProcessError as e:
            print(f"Failed to install service (systemctl exit code {e.returncode}).")
            print(f"You can try manually: systemctl --user enable --now {SERVICE_NAME}")


def resolve_paths(args: argparse.Namespace, *, config_path: Path) -> tuple[Path, Path, Path, Path]:
    """
    Precedence (high -> low):
      CLI args > env vars > config.toml

    Policy:
      - If config file does NOT exist (and not running --install), require BOTH dirs
        via args or env vars (no implicit defaults).
      - If config exists, it must contain BOTH keys unless overridden.
    """
    config_exists = config_path.is_file()
    cfg = load_user_config(config_path) if config_exists else {}

    staging_val = cfg.get("staging_dir")
    mods_val = cfg.get("mods_dir")

    staging_env = os.getenv("HYTALEMODINSTALLER_STAGING_DIR")
    mods_env = os.getenv("HYTALEMODINSTALLER_MODS_DIR")
    if staging_env:
        staging_val = staging_env
    if mods_env:
        mods_val = mods_env

    if getattr(args, "staging_dir", None):
        staging_val = args.staging_dir
    if getattr(args, "mods_dir", None):
        mods_val = args.mods_dir

    if not config_exists:
        if not staging_val or not mods_val:
            raise SystemExit(
                "No config file found. Provide BOTH --staging-dir and --mods-dir "
                "(or set HYTALEMODINSTALLER_STAGING_DIR and HYTALEMODINSTALLER_MODS_DIR), "
                "or run with --install."
            )

    if config_exists and (not staging_val or not mods_val):
        raise SystemExit(
            f"Config file is missing required keys. Expected 'staging_dir' and 'mods_dir' in: {config_path}"
        )

    staging_dir = Path(staging_val).expanduser()
    mods_dir = Path(mods_val).expanduser()

    archive_dir = staging_dir / "installed"
    failed_dir = staging_dir / "failed"
    return staging_dir, mods_dir, archive_dir, failed_dir